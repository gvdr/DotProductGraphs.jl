var documenterSearchIndex = {"docs":
[{"location":"man/embeddings/#Embedding-functions","page":"Embedding functions","title":"Embedding functions","text":"","category":"section"},{"location":"man/embeddings/","page":"Embedding functions","title":"Embedding functions","text":"We provide various functions with which to compute SVD embeddings.","category":"page"},{"location":"man/embeddings/#Detailed-API","page":"Embedding functions","title":"Detailed API","text":"","category":"section"},{"location":"man/embeddings/","page":"Embedding functions","title":"Embedding functions","text":"​","category":"page"},{"location":"man/embeddings/","page":"Embedding functions","title":"Embedding functions","text":"DotProductGraphs.dot_product\nDotProductGraphs.svd_embedding\nDotProductGraphs.truncated_svd","category":"page"},{"location":"man/embeddings/#DotProductGraphs.dot_product","page":"Embedding functions","title":"DotProductGraphs.dot_product","text":"dot_product(L,R;to_prob = true)\n\nComputes the dot product between two embeddings and gives back a matrix of interaction probabilities\n\nThe left and right embeddings must be of the same dimension (e.g., size(L)[2] == size(R)[2]) but can be of different number of nodes (e.g. for bipartite networks).\n\nArguments\n\nL: Left embedding\nR: Right embedding\nto_prob: (optional) whether to clamp the outcomes to the interval [0,1]\n\nExamples\n\njulia> # we first build a 2 blocks matrix:\njulia> block_matrix = reshape([ones(5,5) zeros(5,5); zeros(5,5) ones(5,5)],10,10)\njulia> # and then decompose it:\njulia> L,R = svd_embedding(block_matrix,2)\njulia> dot_product(L,R) ≈ block_matrix\n\n\n\n\n\n","category":"function"},{"location":"man/embeddings/#DotProductGraphs.svd_embedding","page":"Embedding functions","title":"DotProductGraphs.svd_embedding","text":"svd_embedding(A,d; svd_engine = nothing)\n\nComputes an SVD embedding of an adjacency matrix A of dimension d, using svd_engine to perform the SVD factorization\n\nGiven an adjacency matrix A, the function returns its node embedding using the Singular Value Decomposition, as it is done in Random Dot Product Graphs. The functions accepts a user defined svd_engine that can be different from the detaul svd() coming from LinearAlgebra. In that case, svd_engine must be a function of the same form of truncated_svd.\n\nArguments\n\nA: Adjacency matrix of the graph to embed.\nd: Dimension of the embedding\nsvd_engine: The function used to perform the SVD factorization, by default svd() from LinearAlgebra\n\nNotes\n\nThe matrix A can be asymmetric (that is, the graph can be directed) and rectangular (e.g., for bipartite graphs).\n\nExamples\n\njulia> # we first build a 2 blocks matrix:\njulia> block_matrix = reshape([ones(5,5) zeros(5,5); zeros(5,5) ones(5,5)],10,10)\njulia> # and then decompose it:\njulia> L,R = svd_embedding(block_matrix,2)\n\n\n\n\n\n","category":"function"},{"location":"man/embeddings/#DotProductGraphs.truncated_svd","page":"Embedding functions","title":"DotProductGraphs.truncated_svd","text":"truncated_svd(Mat, dim)\n\nComputes a truncated Singular Value Decomposition\n\nJust some rice over the default LinearAlgebra.svd to return a truncated Singular Value Decomposition of dimension d.\n\nArguments\n\nMat: The matrix we want to factorize\nd: The dimension of the factorization\n\nNotes\n\nThis is in general not efficient, as we are computing first a full factorization and then truncating it. We should consider using more optimized methods.\n\nExamples\n\njulia> # we first build a 2 blocks matrix:\njulia> block_matrix = reshape([ones(5,5) zeros(5,5); zeros(5,5) ones(5,5)],10,10)\njulia> # and then decompose it:\njulia> L, Σ, Rt = truncated_svd(block_matrix,2)\n\n\n\n\n\n","category":"function"},{"location":"#DotProductGraphs.jl","page":"Home","title":"DotProductGraphs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Chek it out on DotProductGraphs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov.io) (Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia Package to work with Random Dot Product Graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It should cover all things RDPG, from SVD embeddings of networks, to more advanced functionalities such as omniembeddings, procrustes alignments, and so on.","category":"page"},{"location":"#Functioning","page":"Home","title":"Functioning","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For now, you can retrieve an embedding of a given size:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# we build a random, silly 1,0 matrix A\n# and think of it as a Graph adjacency matrix\nA = rand(Bool,100,100)\n\n# we build a pair of 4 dimensional embeddings\nLeft_embedding, Right_embedding = svd_embedding(A,4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And produce a matrix of interaction probability by dot product:","category":"page"},{"location":"","page":"Home","title":"Home","text":"P = dot_product(Left_embedding, Right_embedding)","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[ ] Document all the things!\n[ ] Unit Tests All The Things!\n[x] Include basic embedding and dot product capability relying on LinearAlgebra\n[ ] Allow user to choose the svd \"engine\" (e.g., KrylovKit.JL, Arpack.JL, LowRankApprox.jl, ...) by defining a unified interface\n[ ] Implement Omniembedding functions\n[x] Automatic block matrix building\n[ ] Embedding extraction\n[ ] Implement Procrustes Allignment\n[ ] orthogonal\n[x] Partial: Just getting the min distances (cheating, as we compute the full rotation matrix)\n[x] Full: Obtaining rotation matrix\n[ ] allowing translations\n[ ] seedless\n[ ] Elbow and principled method to choose dimensionality\n[ ] Register package.\n[ ] Think how to integrate with Graphs.jl and EcologicalNetworks.jl","category":"page"},{"location":"#Acknowledgement","page":"Home","title":"Acknowledgement","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DotProductGraphs is heavily inspired by graspologic, but it focus on being light (focussing on a narrower set of techniques, as we complement wider ecosystems as Graphs.jl and EcologicalNetworks.jl) and squeezing out performance from being written in Julia.","category":"page"}]
}
